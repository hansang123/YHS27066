1.VCS: 버전 관리: VCS는 파일의 변경 이력을 추적하고 각 변경 사항에 대한 버전을 관리합니다. 이를 통해 이전 버전으로 되돌릴 수 있고, 변경 내역을 비교하고 병합할 수 있습니다.

협업: 여러 개발자가 동시에 작업할 때 VCS를 사용하면 충돌을 최소화하고 변경 사항을 쉽게 공유할 수 있습니다. 각 개발자는 자신의 작업을 분리된 브랜치(branch)에서 진행하고, 이를 메인 코드베이스에 통합할 수 있습니다.

백업 및 복원: VCS는 코드와 파일의 백업을 제공하며, 실수로 삭제한 파일이나 변경 사항을 복구할 수 있는 기능을 제공합니다.

추적 및 검색: VCS를 사용하면 파일 변경 이력을 추적하고 검색할 수 있습니다. 특정 변경 사항을 신속하게 찾거나 코드의 특정 부분이 언제 수정되었는지 알 수 있습니다.

대표적인 VCS로는 Git, Subversion(SVN), Mercurial 등이 있습니다. 이 중 Git은 가장 널리 사용되는 분산형 VCS로 알려져 있습니다. Git은 빠르고 유연하며 강력한 분기(branch) 및 병합(merge) 기능을 제공하여 대규모 프로젝트의 버전 관리를 효율적으로 지원합니다.


2. DVCS와 VCS의 차이점

중앙 집중형 버전 관리 시스템(VCS): 중앙 서버에 프로젝트의 단일 버전이 저장되며, 사용자는 중앙 서버에서 파일을 체크아웃하여 작업하고 변경 사항을 커밋합니다. 대표적인 예로는 Subversion(SVN)이 있습니다.
분산형 버전 관리 시스템(DVCS): 각 사용자가 전체 저장소의 복제본을 가지고 있으며, 로컬 저장소에서 작업한 후 변경 사항을 중앙 서버에 푸시합니다. 대표적인 예로는 Git이 있습니다.
작업 속도와 오프라인 작업:

VCS: 중앙 서버와의 통신이 필요하므로 네트워크 속도에 영향을 받을 수 있으며, 오프라인 상태에서는 작업할 수 없습니다.
DVCS: 로컬 저장소에서 작업하기 때문에 네트워크 속도에 영향을 받지 않으며, 오프라인에서도 작업할 수 있습니다.
복제와 브랜치 관리:

VCS: 일반적으로 중앙 서버에서만 브랜치를 생성하고 관리할 수 있습니다.
DVCS: 각 사용자가 로컬에서 브랜치를 만들고 관리할 수 있습니다. 이는 협업과 병합을 더 유연하게 만듭니다.
보안:

VCS: 중앙 서버가 한 곳에 집중되어 있기 때문에 접근 제어 및 보안 관리가 중요합니다.
DVCS: 각 사용자가 로컬 저장소를 가지고 있기 때문에 중앙 서버가 해킹되더라도 프로젝트의 전체 손상을 방지할 수 있습니다.
확장성과 성능:

VCS: 대규모 프로젝트에서는 중앙 서버의 부하와 성능 이슈가 발생할 수 있습니다.
DVCS: 각 사용자가 로컬에서 작업하기 때문에 대규모 프로젝트에도 뛰어난 확장성과 성능을 제공합니다.
요약하면, DVCS는 분산된 작업 환경에서 유연하게 협업하고 프로젝트를 관리할 수 있는 강력한 도구이며, VCS는 중앙 집중식 환경에서 사용됩니다. Git은 대표적인 DVCS의 예시이며, Subversion(SVN)은 대표적인 VCS의 예시입니다

![1p](https://github.com/hansang123/YHS27066/assets/162859949/c9eed399-6fe5-4f5f-8668-4e3f17ead90c)
3-1 : 폴더에서 바로 git bash 여는법 


![2p](https://github.com/hansang123/YHS27066/assets/162859949/4cef1e9c-8e03-41c6-b720-a4d73e20c32a)
3-2 : git init 명령어는 Git 저장소를 초기화하는 데 사용됩니다. 이 명령을 사용하면 현재 작업 디렉토리에 새로운 Git 저장소가 생성됩니다. 이 저장소에는 프로젝트의 버전 관리를 위한 모든 Git 관련 파일과 폴더가 생성됩니다.

git init 명령을 실행하면 다음과 같은 작업이 수행됩니다

.git이라는 숨겨진 디렉토리가 생성됩니다. 이 디렉토리에는 Git 저장소의 모든 정보가 저장됩니다.

초기 설정 파일이 생성됩니다. .git/config 파일에는 저장소의 설정 정보가 저장됩니다.

:본 브랜치인 master가 생성됩니다. 이 브랜치는 초기 커밋을 가리킵니다.

이 명령을 실행하면 현재 디렉토리가 Git 저장소로 초기화되고, 프로젝트의 버전 관리를 시작할 수 있습니다.<br/>

![3p](https://github.com/hansang123/YHS27066/assets/162859949/3a81f7cc-4fb1-4010-ae22-187739e43ad3)
3-3: git branch -m master main 명령어는 Git에서 사용되는 명령어로, Git 저장소에서 기본 브랜치의 이름을 변경하는 데 사용됩니다. 이 명령어는 기존에 master로 설정되어 있던 기본 브랜치를 main으로 변경합니다.
어휘적인 변화: "master"라는 용어는 과거에는 주로 사용되었지만, 현재에는 이 용어가 포함된 문화적, 사회적 콘텍스트에 대해 논란이 있습니다. "main"이라는 용어는 이러한 논란을 피하기 위한 대안으로 사용됩니다.

다양성과 포용: 프로젝트가 다양성과 포용성을 강조할 때, "main"과 같은 보다 중립적인 용어를 선호할 수 있습니다.

표준화: Git을 사용하는 많은 프로젝트가 기본 브랜치의 이름을 "main"으로 변경함으로써 일관성을 유지하려고 합니다.<br/>


![4p](https://github.com/hansang123/YHS27066/assets/162859949/e530c463-42bc-4fd7-8cf7-2f9a1634a2a0)
3-4: git remote add origin 명령어는 Git에서 사용되는 명령어 중 하나로, 로컬 Git 저장소에 원격 저장소를 추가하는 데 사용됩니다.

여기서 "원격 저장소"란, 프로젝트의 중앙 저장소로서 인터넷이나 네트워크 상의 다른 위치에 있는 Git 저장소를 의미합니다. 일반적으로 GitHub, GitLab, Bitbucket 등의 호스팅 서비스에 프로젝트를 업로드하고 관리하는 데 사용됩니다.

이후에는 origin이라는 이름으로 원격 저장소가 로컬 저장소에 추가되었으므로, 이를 통해 원격 저장소와 상호작용할 수 있습니다. 이제 git push origin master와 같은 명령어로 로컬 변경 사항을 원격 저장소로 푸시할 수 있습니다.

4..gitignore : .gitignore 파일은 Git 저장소에서 버전 관리를 하지 않아야 할 파일이나 디렉토리를 지정하는 데 사용됩니다. 이 파일은 Git이 특정 파일을 추적하지 않도록 설정하고 .gitignore 파일은 저장소의 루트 디렉토리에 위치합니다.

사용법 및 작성 방식
패턴 작성:

패턴 작성: .gitignore 파일에는 무시하려는 파일이나 디렉토리의 패턴을 작성합니다. 이 패턴은 파일 이름이나 디렉토리 이름에 대한 것입니다. 와일드카드를 사용하여 여러 파일을 지정할 수 있습니다.

주석: # 기호로 시작하는 줄은 주석으로 처리되며, Git은 이를 무시합니다. 주석은 파일 내에서 설명을 추가하는 데 사용됩니다.

디렉토리 지정: 특정 디렉토리의 모든 파일을 무시하려면 해당 디렉토리 이름을 작성합니다.

와일드카드 사용: 와일드카드를 사용하여 패턴을 더욱 유연하게 지정할 수 있습니다. 예를 들어, *.log는 모든 확장자가 .log인 파일을 무시합니다.

부정 패턴: ! 기호를 사용하여 특정 파일이나 디렉토리를 무시하지 않도록 설정할 수 있습니다


5.

5-1:헤더(Header)
헤더는 문서의 섹션을 정의하는 데 사용됩니다. #을 통해 헤더의 수준을 나타냅니다. 수준이 높을수록 작은 크기의 헤더가 됩니다.
```markdown
# 제목1
## 제목2
### 제목3


```

# 제목1
## 제목2
### 제목3




5-2: 목록 (숫자)
순서가 있는 목록을 만들 때 사용합니다.
```markdown
1. 항목1
2. 항목2
3. 항목3
```

1. 항목 1
2. 항목 2
3. 항목 3

숫자 목록에서 각 항목의 번호는 입력된 순서대로 자동으로 부여되며, 숫자를 직접 입력하지 않아도 됩니다. 숫자가 지정되지 않으면 마크다운 렌더링 엔진이 자동으로 순서를 매겨줍니다. 따라서 아래와 같이 입력해도 동일한 결과를 얻을 수 있습니다:


5-3:순서 없는 목록 (Bullet)
순서가 없는 목록을 만들 때 사용합니다. 별표(*), 더하기(+), 대시(-)를 사용할 수 있습니다.
```markdown
* 항목1
+ 항목2
- 항목3

```
* 항목1
+ 항목2
- 항목3



5-4: 들여쓰기
1. 탭(Tab) 사용:
들여쓰기를 하려는 줄의 앞에 탭을 사용합니다. 여러 번 탭을 사용하면 들여쓰기의 수준이 증가합니다.

예를 들어:

```markdown
- 항목 1
    - 하위 항목 1
        - 하위 항목 2
    - 하위 항목 3
- 항목 2
```
위의 예시는 다음과 같이 나타납니다:


- 항목 1
    - 하위 항목 1
        - 하위 항목 2
    - 하위 항목 3
- 항목 2







5-5:코드블럭

일반적으로 마크다운에서 코드 블록은 백틱 (`)을 사용하여 만듭니다. 코드 블록을 생성하려면 백틱 세 개를 코드의 시작과 끝에 각각 삽입합니다

마크다운에서 코드 블록을 사용하는 기본적인 형식은 다음과 같습니다:




여기서 [language] 부분에는 코드가 작성된 프로그래밍 언어를 지정합니다. 만약 언어를 명시하지 않는다면, 일반적으로 텍스트로 간주되어 문법 강조가 적용되지 않습니다.


5-6 수평선(hr도가능<>안에)

```markdown

* * *
***

*****

- - -

----------------------------------------
```

* * *
***

*****

- - -

---------------------------------------




5-7: 
1. 인라인 링크:
인라인 링크는 링크 텍스트와 해당 링크 URL을 직접 포함하여 만드는 방식입니다. 다음과 같은 구조를 가집니다

[링크 텍스트](링크 URL)

여기서:
링크 텍스트: 링크에 표시되는 텍스트입니다.
링크 URL: 링크가 이동할 주소입니다.


예를 들어:
```markdown
[Google](https://www.google.com)
```
위의 예시는 다음과 같이 나타납니다:
Google



2. 참조 링크:
참조 링크는 링크 텍스트와 URL을 분리하여 정의하는 방식입니다. 링크 텍스트와 URL을 구분하고, 나중에 해당 링크 텍스트에 대한 참조를 정의합니다. 다음과 같은 구조를 가집니다:

[링크 텍스트][참조명]
그리고 참조를 정의하는 부분은 다음과 같습니다:

[참조명]: 링크 URL


예를 들어:

```markdown
[Google][1]
[1]: https://www.google.com
```

위의 예시는 인라인 링크와 동일한 결과를 생성합니다:
Google


링크 텍스트와 URL 사이에는 공백이 있어선 안 되며, 링크 URL이 괄호 안에 포함되어야 합니다. 이를 통해 원하는 링크를 만들어 낼 수 있습니다.




5-8:이미지

이미지 파일의 URL을 사용하여 이미지를 참조하면 됩니다.

이미지 타이틀은 이미지에 대한 부가적인 설명이나 정보를 제공하는 HTML 속성 중 하나입니다. 이미지 타이틀은 보통 이미지를 설명하거나 추가 정보를 제공하는 용도로 사용됩니다

![대체 텍스트](이미지 URL)

![대체 텍스트](이미지 URL "이미지 타이틀")

예:
```
![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg "Optional title")

```

여기서 대체 텍스트는 이미지를 설명하는 텍스트이며, 이미지 URL은 이미지 파일의 주소입니다. 대체 텍스트는 이미지를 로드할 수 없을 때 대신 표시됩니다.
사이즌느 HTML 태그를 사용하여 이미지의 크기를 조절할 수 있다:

예 :
```
<img src="/path/to/img.jpg" width="450px" height="300px" title="px(픽셀) 크기 설정" alt="RubberDuck"></img><br/>
<img src="/path/to/img.jpg" width="40%" height="30%" title="px(픽셀) 크기 설정" alt="RubberDuck"></img>

```


5-9 강조:
```
**굵게**  
*기울임*  
***굵게 기울임***  
~~취소선~~  
`인라인 코드`
```
위의 마크다운 코드를 사용하여 다음과 같은 결과를 얻을 수 있습니다:

**굵게**
*기울임*
***굵게 기울임***
~~취소선~~
`인라인 코드`


